import { db } from '@/lib/db';
import { chats, messages, users } from '@/lib/db/schema';
import { eq, desc, and, sql, asc } from 'drizzle-orm'; // Added asc
import { alias } from 'drizzle-orm/pg-core';
import { getCurrentUserId } from '@/lib/auth/get-current-user'; // We'll use this to ensure user-specific actions

// Define types based on our schema for better type safety
// These would ideally be generated by Drizzle Kit or defined in a central types location in a larger app
export type Chat = typeof chats.$inferSelect;
export type Message = typeof messages.$inferSelect;
export type User = typeof users.$inferSelect;
export type NewChat = typeof chats.$inferInsert;
export type NewMessage = typeof messages.$inferInsert;

/**
 * Retrieves a specific chat by its ID, ensuring it belongs to the current user
 * or is public.
 * @param id - The ID of the chat to retrieve.
 * @param userId - The ID of the user requesting the chat.
 * @returns The chat object if found and accessible, otherwise null.
 */
export async function getChat(id: string, userId: string): Promise<Chat | null> {
  if (!userId) {
    console.warn('getChat called without userId');
    // Potentially allow fetching public chats if userId is null for anonymous users
    const result = await db.select().from(chats).where(and(eq(chats.id, id), eq(chats.visibility, 'public'))).limit(1);
    return result[0] || null;
  }

  const result = await db.select()
    .from(chats)
    .where(
      and(
        eq(chats.id, id),
        sql`${chats.userId} = ${userId} OR ${chats.visibility} = 'public'`
      )
    )
    .limit(1);
  return result[0] || null;
}

/**
 * Retrieves a paginated list of chats for a given user.
 * @param userId - The ID of the user whose chats to retrieve.
 * @param limit - The maximum number of chats to return.
 * @param offset - The number of chats to skip (for pagination).
 * @returns An object containing the list of chats and the next offset.
 */
export async function getChatsPage(
  userId: string,
  limit: number = 20,
  offset: number = 0
): Promise<{ chats: Chat[]; nextOffset: number | null }> {
  if (!userId) {
    console.error('getChatsPage called without userId.');
    return { chats: [], nextOffset: null };
  }
  const result = await db
    .select()
    .from(chats)
    .where(eq(chats.userId, userId))
    .orderBy(desc(chats.createdAt))
    .limit(limit)
    .offset(offset);

  let nextOffset: number | null = null;
  if (result.length === limit) {
    nextOffset = offset + limit;
  }

  return { chats: result, nextOffset };
}

/**
 * Saves a chat and its messages. If the chat exists, it updates it.
 * This function should handle both creating new chats and appending messages.
 * The PR implies complex logic for saving, including message IDs.
 * This is a simplified version; PR #533 might have more granular message saving.
 * @param chatData - The chat data to save.
 * @param messagesData - An array of messages to save with the chat.
 * @returns The saved chat ID.
 */
export async function saveChat(chatData: NewChat, messagesData: Omit<NewMessage, 'chatId'>[]): Promise<string | null> {
  if (!chatData.userId) {
    console.error('Cannot save chat without a userId');
    return null;
  }

  // Transaction to ensure atomicity
  return db.transaction(async (tx) => {
    let chatId = chatData.id;

    if (chatId) { // If chat ID is provided, assume update or append messages
      const existingChat = await tx.select({ id: chats.id }).from(chats).where(eq(chats.id, chatId)).limit(1);
      if (!existingChat.length) {
        // Chat doesn't exist, so create it
        const newChatResult = await tx.insert(chats).values(chatData).returning({ id: chats.id });
        chatId = newChatResult[0].id;
      } else {
        // Optionally update chat metadata here if needed, e.g., title
        if (chatData.title) {
          await tx.update(chats).set({ title: chatData.title }).where(eq(chats.id, chatId));
        }
      }
    } else { // No chat ID, create new chat
      const newChatResult = await tx.insert(chats).values(chatData).returning({ id: chats.id });
      chatId = newChatResult[0].id;
    }

    if (!chatId) {
      // console.error('Failed to establish chatId within transaction.'); // Optional: for server logs
      throw new Error('Failed to establish chatId for chat operation.');
    }

    // Save messages
    if (messagesData && messagesData.length > 0) {
      const messagesToInsert = messagesData.map(msg => ({
        ...msg,
        chatId: chatId!, // Ensure chatId is set for all messages
        userId: msg.userId || chatData.userId!, // Ensure userId is set
      }));
      await tx.insert(messages).values(messagesToInsert);
    }
    return chatId;
  });
}


/**
 * Creates a single message within a chat.
 * PR #533 has commits like "feat: Add message update and trailing deletion logic",
 * suggesting more granular message operations. This is a basic create.
 * @param messageData - The message data to save.
 * @returns The created message object or null if error.
 */
export async function createMessage(messageData: NewMessage): Promise<Message | null> {
  if (!messageData.chatId || !messageData.userId || !messageData.role || !messageData.content) {
    console.error('Missing required fields for creating a message.');
    return null;
  }
  try {
    const result = await db.insert(messages).values(messageData).returning();
    return result[0] || null;
  } catch (error) {
    console.error('Error creating message:', error);
    return null;
  }
}

/**
 * Deletes a specific chat and its associated messages (due to cascade delete).
 * @param id - The ID of the chat to delete.
 * @param userId - The ID of the user requesting deletion, for authorization.
 * @returns True if deletion was successful, false otherwise.
 */
export async function deleteChat(id: string, userId: string): Promise<boolean> {
  if (!userId) {
    console.error('deleteChat called without userId.');
    return false;
  }
  try {
    const result = await db
      .delete(chats)
      .where(and(eq(chats.id, id), eq(chats.userId, userId))) // Ensure user owns the chat
      .returning({ id: chats.id });
    return result.length > 0;
  } catch (error) {
    console.error('Error deleting chat:', error);
    return false;
  }
}

/**
 * Clears the chat history for a given user (deletes all their chats).
 * @param userId - The ID of the user whose chat history to clear.
 * @returns True if history was cleared, false otherwise.
 */
export async function clearHistory(userId: string): Promise<boolean> {
  if (!userId) {
    console.error('clearHistory called without userId.');
    return false;
  }
  try {
    // This will also delete associated messages due to cascade delete constraint
    await db.delete(chats).where(eq(chats.userId, userId));
    return true;
  } catch (error) {
    console.error('Error clearing history:', error);
    return false;
  }
}

/**
 * Retrieves all messages for a given chat ID, ordered by creation time.
 * @param chatId - The ID of the chat whose messages to retrieve.
 * @returns An array of message objects.
 */
export async function getMessagesByChatId(chatId: string): Promise<Message[]> {
  if (!chatId) {
    console.warn('getMessagesByChatId called without chatId');
    return [];
  }
  try {
    const result = await db
      .select()
      .from(messages)
      .where(eq(messages.chatId, chatId))
      .orderBy(asc(messages.createdAt)); // Order messages chronologically
    return result;
  } catch (error) {
    console.error(`Error fetching messages for chat ${chatId}:`, error);
    return [];
  }
}

// More granular functions might be needed based on PR #533 specifics:
// - updateMessage(messageId: string, updates: Partial<NewMessage>): Promise<Message | null>
// - deleteMessage(messageId: string, userId: string): Promise<boolean>
// - deleteTrailingMessages(chatId: string, lastKeptMessageId: string): Promise<void>
// These are placeholders for now and can be implemented if subsequent steps show they are directly part of PR #533's changes.
// The PR mentions "feat: Add message update and trailing deletion logic" and "refactor(chat): Adjust message edit logic".

console.log('Chat DB actions loaded. Ensure getCurrentUserId() is correctly implemented for server-side usage if applicable.');
